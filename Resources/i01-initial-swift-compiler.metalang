.SYNTAX PROGRAM

[ body of compiler definition ]

PROGRAM = '.SYNTAX' ID
          .OUT('// ' * ' compiler' .NL)
          .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH()
          .NODE(.NODETEXT '// ' * ' compiler' .NL)
          .OUT('public class Compiler {' .LM+ .NL .NL) .NODE(.NODETEXT 'public class Compiler {' .LM+ .NL .NL)
          .NODECONTEXTPOP()
          PREAMBLE
          $(PR / COMMENT)
          '.TOKENS'
          $(TR / COMMENT)
          '.END'
          POSTAMBLE
          .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH()
          .OUT(.LM- '}' .NL) .NODE(.NODETEXT .LM- '}' .NL)
          .NODECONTEXTPOP()
          ;

[ object definition preamble ]
PREAMBLE = .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH()
           .OUT('public func compile(_ input: String) throws {' .LM+ .NL) .NODE(.NODETEXT 'public func compile(_ input: String) throws {' .LM+ .NL)
           .OUT('// initialize compiler variables' .NL) .NODE(.NODETEXT '// initialize compiler variables' .NL)
           .OUT('self.inbuf = input' .NL) .NODE(.NODETEXT 'self.inbuf = input' .NL)
           .OUT('self.initialize()' .NL) .NODE(.NODETEXT 'self.initialize()' .NL)
           .OUT('// call the first rule' .NL) .NODE(.NODETEXT '// call the first rule' .NL)
           .OUT('try self.rule' * '()' .NL) .NODE(.NODETEXT 'try self.rule' * '()' .NL)
           .OUT('// special case handling of first rule failure' .NL) .NODE(.NODETEXT '// special case handling of first rule failure' .NL)
           .OUT('if !self.isParsed {' .LM+ .NL) .NODE(.NODETEXT 'if !self.isParsed {' .LM+ .NL)
           .OUT('throw CompilerError.parseFailure(rule: ' 34 * 34 ', inputOffset: self.inp)' .NL) .NODE(.NODETEXT 'throw CompilerError.parseFailure(rule: ' 34 * 34 ', inputOffset: self.inp)' .NL)
           .OUT(.LM- '}' .NL) .NODE(.NODETEXT .LM- '}' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)
           .NODECONTEXTPOP()
           ;


[ runtime and object definition postamble ]
POSTAMBLE =
           .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH()
           .OUT('struct StackFrame {' .LM+ .NL) .NODE(.NODETEXT 'struct StackFrame {' .LM+ .NL)
           .OUT('var erule: String' .NL) .NODE(.NODETEXT 'var erule: String' .NL)
           .OUT('var leftMargin: Int' .NL) .NODE(.NODETEXT 'var leftMargin: Int' .NL)
           .OUT(.LM- '}' .NL) .NODE(.NODETEXT .LM- '}' .NL)

           .OUT('// runtime variables' .NL) .NODE(.NODETEXT '// runtime variables' .NL)
           .OUT('var isParsed = false' .NL) .NODE(.NODETEXT 'var isParsed = false' .NL)
           .OUT('var isToken = false' .NL) .NODE(.NODETEXT 'var isToken = false' .NL)
           .OUT('var inp = 0' .NL) .NODE(.NODETEXT 'var inp = 0' .NL)
           .OUT('var inbuf = ' 34 34 .NL) .NODE(.NODETEXT 'var inbuf = ' 34 34 .NL)
           .OUT('public var outputBuffer = ' 34 34 .NL) .NODE(.NODETEXT 'public var outputBuffer = ' 34 34 .NL)
           .OUT('public var token = ' 34 34 .NL) .NODE(.NODETEXT 'public var token = ' 34 34 .NL)
           .OUT('public var rootAST = Node(type: .root)' .NL) .NODE(.NODETEXT 'public var rootAST = Node(type: .root)' .NL)
           .OUT('var currentNode: Node?' .NL) .NODE(.NODETEXT 'var currentNode: Node?' .NL)
           .OUT('var latestNode: Node?' .NL) .NODE(.NODETEXT 'var latestNode: Node?' .NL)
           .OUT('var nodeContextStack: [Node] = []' .NL) .NODE(.NODETEXT 'var nodeContextStack: [Node] = []' .NL)
           .OUT('var stashedNodes: [Node] = []' .NL) .NODE(.NODETEXT 'var stashedNodes: [Node] = []' .NL)
           .OUT('var stack: [StackFrame] = []' .NL .NL) .NODE(.NODETEXT 'var stack: [StackFrame] = []' .NL .NL)

           .OUT('public init() {'.LM+ .NL) .NODE(.NODETEXT 'public init() {'.LM+ .NL)
           .OUT('self.initialize()' .NL) .NODE(.NODETEXT 'self.initialize()' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func initialize () {'.LM+ .NL) .NODE(.NODETEXT 'func initialize () {'.LM+ .NL)
           .OUT('// initialize for another compile' .NL) .NODE(.NODETEXT '// initialize for another compile' .NL)
           .OUT('self.isParsed = false' .NL) .NODE(.NODETEXT 'self.isParsed = false' .NL)
           .OUT('self.isToken = false' .NL) .NODE(.NODETEXT 'self.isToken = false' .NL)
           .OUT('self.inp = 0' .NL) .NODE(.NODETEXT 'self.inp = 0' .NL)
           .OUT('self.outputBuffer = ' 34 34 .NL) .NODE(.NODETEXT 'self.outputBuffer = ' 34 34 .NL)
           .OUT('self.token = ' 34 34 .NL) .NODE(.NODETEXT 'self.token = ' 34 34 .NL)
           .OUT('self.stack = []' .NL) .NODE(.NODETEXT 'self.stack = []' .NL)
           .OUT('self.rootAST = Node(type: .root)' .NL) .NODE(.NODETEXT 'self.rootAST = Node(type: .root)' .NL)
           .OUT('self.currentNode = rootAST' .NL) .NODE(.NODETEXT 'self.currentNode = rootAST' .NL)
           .OUT('self.nodeContextStack = []' .NL) .NODE(.NODETEXT 'self.nodeContextStack = []' .NL)
           .OUT('self.stashedNodes = []' .NL) .NODE(.NODETEXT 'self.stashedNodes = []' .NL)

           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func contextPush(_ rulename: String) {' .LM+ .NL) .NODE(.NODETEXT 'func contextPush(_ rulename: String) {' .LM+ .NL)
           .OUT('// push and initialize a new stackframe' .NL) .NODE(.NODETEXT '// push and initialize a new stackframe' .NL)
           .OUT('// new context inherits current context left margin' .NL) .NODE(.NODETEXT '// new context inherits current context left margin' .NL)
           .OUT('var leftMargin = 0' .NL 'if self.stack.count >= 1 { leftMargin = self.stack[self.stack.count - 1].leftMargin }' .NL) .NODE(.NODETEXT 'var leftMargin = 0' .NL 'if self.stack.count >= 1 { leftMargin = self.stack[self.stack.count - 1].leftMargin }' .NL)
           .OUT('// stackframe definition' .NL) .NODE(.NODETEXT '// stackframe definition' .NL)
           .OUT('self.stack.append(StackFrame(erule: rulename, leftMargin: leftMargin))' .NL) .NODE(.NODETEXT 'self.stack.append(StackFrame(erule: rulename, leftMargin: leftMargin))' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func contextPop() {' .LM+ .NL) .NODE(.NODETEXT 'func contextPop() {' .LM+ .NL)
           .OUT('// pop and possibly deallocate old stackframe' .NL) .NODE(.NODETEXT '// pop and possibly deallocate old stackframe' .NL)
           .OUT('_ = self.stack.popLast() // pop stackframe' .NL) .NODE(.NODETEXT '_ = self.stack.popLast() // pop stackframe' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func out(_ output: String) {' .LM+ .NL) .NODE(.NODETEXT 'func out(_ output: String) {' .LM+ .NL)
           .OUT('// output string' .NL) .NODE(.NODETEXT '// output string' .NL)
           .OUT('var indent = 0' .NL) .NODE(.NODETEXT 'var indent = 0' .NL)
           .OUT('// if newline last output, add left margin before string' .NL) .NODE(.NODETEXT '// if newline last output, add left margin before string' .NL)
           .OUT('if self.outputBuffer.count > 0 && String(UnicodeScalar(Array(self.outputBuffer.utf8)[self.outputBuffer.count - 1])) == ' 34 92 'n' 34 ' {' .NL) .NODE(.NODETEXT 'if self.outputBuffer.count > 0 && String(UnicodeScalar(Array(self.outputBuffer.utf8)[self.outputBuffer.count - 1])) == ' 34 92 'n' 34 ' {' .NL)
           .OUT('  indent = self.stack[self.stack.count - 1].leftMargin' .NL) .NODE(.NODETEXT '  indent = self.stack[self.stack.count - 1].leftMargin' .NL)
           .OUT('  while indent > 0 { self.outputBuffer += ' 34 ' ' 34 '; indent -= 1 } }' .NL) .NODE(.NODETEXT '  while indent > 0 { self.outputBuffer += ' 34 ' ' 34 '; indent -= 1 } }' .NL)
           .OUT('self.outputBuffer += output' .NL) .NODE(.NODETEXT 'self.outputBuffer += output' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func add(childNode: Node) {' .LM+ .NL) .NODE(.NODETEXT 'func add(childNode: Node) {' .LM+ .NL)
           .OUT('currentNode?.children.append(childNode)' .NL) .NODE(.NODETEXT 'currentNode?.children.append(childNode)' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func pushLastChildAsNodeContext() {' .LM+ .NL) .NODE(.NODETEXT 'func pushLastChildAsNodeContext() {' .LM+ .NL)
           .OUT('nodeContextStack.append(currentNode!)' .NL) .NODE(.NODETEXT 'nodeContextStack.append(currentNode!)' .NL)
           .OUT('currentNode = currentNode!.children.last!' .NL) .NODE(.NODETEXT 'currentNode = currentNode!.children.last!' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func popNodeContext() {' .LM+ .NL) .NODE(.NODETEXT 'func popNodeContext() {' .LM+ .NL)
           .OUT('currentNode = nodeContextStack.popLast()!' .NL) .NODE(.NODETEXT 'currentNode = nodeContextStack.popLast()!' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func stash(node: Node) {' .LM+ .NL) .NODE(.NODETEXT 'func stash(node: Node) {' .LM+ .NL)
           .OUT('stashedNodes.append(node)' .NL) .NODE(.NODETEXT 'stashedNodes.append(node)' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func popNodeStash() {' .LM+ .NL) .NODE(.NODETEXT 'func popNodeStash() {' .LM+ .NL)
           .OUT('currentNode?.children.append(contentsOf: stashedNodes)' .NL 'stashedNodes = []' .NL) .NODE(.NODETEXT 'currentNode?.children.append(contentsOf: stashedNodes)' .NL 'stashedNodes = []' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func eol () {' .LM+ .NL) .NODE(.NODETEXT 'func eol () {' .LM+ .NL)
           .OUT('// output end of line' .NL) .NODE(.NODETEXT '// output end of line' .NL)
           .OUT('self.outputBuffer += ' 34 92 'n' 34 .NL) .NODE(.NODETEXT 'self.outputBuffer += ' 34 92 'n' 34 .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func test (_ stringToCompare: String) {' .LM+ .NL) .NODE(.NODETEXT 'func test (_ stringToCompare: String) {' .LM+ .NL)
           .OUT('// test for a string in the input' .NL) .NODE(.NODETEXT '// test for a string in the input' .NL)
           .OUT('var inputOffset = 0' .NL) .NODE(.NODETEXT 'var inputOffset = 0' .NL)
           .OUT('// delete whitespace' .NL) .NODE(.NODETEXT '// delete whitespace' .NL)
           .OUT('while Array(self.inbuf.utf8)[self.inp] == 32 ||' .NL) .NODE(.NODETEXT 'while Array(self.inbuf.utf8)[self.inp] == 32 ||' .NL)
           .OUT('       Array(self.inbuf.utf8)[self.inp] == 9 ||' .NL) .NODE(.NODETEXT '       Array(self.inbuf.utf8)[self.inp] == 9 ||' .NL)
           .OUT('       Array(self.inbuf.utf8)[self.inp] == 13 ||' .NL) .NODE(.NODETEXT '       Array(self.inbuf.utf8)[self.inp] == 13 ||' .NL)
           .OUT('       Array(self.inbuf.utf8)[self.inp] == 10 { self.inp += 1}' .NL) .NODE(.NODETEXT '       Array(self.inbuf.utf8)[self.inp] == 10 { self.inp += 1}' .NL)
           .OUT('// test string case insensitive' .NL) .NODE(.NODETEXT '// test string case insensitive' .NL)
           .OUT('self.isParsed = true' .NL) .NODE(.NODETEXT 'self.isParsed = true' .NL)
           .OUT('while self.isParsed && (inputOffset < stringToCompare.count) && ((self.inp + inputOffset) < self.inbuf.count) {' .NL) .NODE(.NODETEXT 'while self.isParsed && (inputOffset < stringToCompare.count) && ((self.inp + inputOffset) < self.inbuf.count) {' .NL)
           .OUT('self.isParsed = String(UnicodeScalar(Array(stringToCompare.utf8)[inputOffset])).uppercased() ==' .NL) .NODE(.NODETEXT 'self.isParsed = String(UnicodeScalar(Array(stringToCompare.utf8)[inputOffset])).uppercased() ==' .NL)
           .OUT('                String(UnicodeScalar(Array(self.inbuf.utf8)[self.inp + inputOffset])).uppercased()' .NL) .NODE(.NODETEXT '                String(UnicodeScalar(Array(self.inbuf.utf8)[self.inp + inputOffset])).uppercased()' .NL)
           .OUT('  inputOffset += 1 }' .NL) .NODE(.NODETEXT '  inputOffset += 1 }' .NL)
           .OUT('self.isParsed = self.isParsed && (inputOffset == stringToCompare.count)' .NL) .NODE(.NODETEXT 'self.isParsed = self.isParsed && (inputOffset == stringToCompare.count)' .NL)
           .OUT('// advance input if found' .NL) .NODE(.NODETEXT '// advance input if found' .NL)
           .OUT('if self.isParsed { self.inp = self.inp + stringToCompare.count }' .NL) .NODE(.NODETEXT 'if self.isParsed { self.inp = self.inp + stringToCompare.count }' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('public enum CompilerError: Error {' .LM+ .NL) .NODE(.NODETEXT 'public enum CompilerError: Error {' .LM+ .NL)
           .OUT('case parseFailure(rule: String, inputOffset: Int)' .NL) .NODE(.NODETEXT 'case parseFailure(rule: String, inputOffset: Int)' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)

           .OUT('func err() throws {' .LM+ .NL) .NODE(.NODETEXT 'func err() throws {' .LM+ .NL)
           .OUT('// compilation error, provide error indication and context' .NL) .NODE(.NODETEXT '// compilation error, provide error indication and context' .NL)
           .OUT('throw CompilerError.parseFailure(rule: self.stack[self.stack.count - 1].erule, inputOffset: self.inp)' .NL) .NODE(.NODETEXT 'throw CompilerError.parseFailure(rule: self.stack[self.stack.count - 1].erule, inputOffset: self.inp)' .NL)
           .OUT(.LM- '}' .NL .NL) .NODE(.NODETEXT .LM- '}' .NL .NL)
           .NODECONTEXTPOP()
           ;

[ parsing rule definition ]
PR = ID .OUT('func rule'* '() throws {' .LM+ .NL) .NODE(.NODERULE) .NODEADDCHILD()
     .NODECONTEXTPUSH()
     .OUT('self.contextPush(' 34 * 34 ')' .NL)
     .OUT('defer { self.contextPop() }' .NL)
     '=' EX1 ';'
     .OUT(.LM- '}' .NL .NL)
     .NODECONTEXTPOP()
     ;

[ token rule definition ]
TR = ID .OUT('func rule'* '() throws {' .LM+ .NL) .NODE(.NODERULE) .NODEADDCHILD()
     .NODECONTEXTPUSH()
     .OUT('self.contextPush(' 34 * 34 ')' .NL)
     .OUT('defer { self.contextPop() }' .NL)
     ':' TX1 ';'
     .OUT(.LM- '}' .NL .NL)
     .NODECONTEXTPOP()
     ;

[ comment definition ]
COMMENT = '[' CMLINE ']' .OUT('//' * .NL) .NODE(.NODECOMMENT) .NODEADDCHILD()
          ;

[ parsing expressions ]
EX1 = .NODE(.NODEOR) .NODEADDCHILD() .NODECONTEXTPUSH() EX2 $('/' .OUT('if !self.isParsed {' .LM+ .NL) EX2 .OUT(.LM- '}' .NL) ) .NODECONTEXTPOP() ;

EX2 = .NODE(.NODEAND) .NODEADDCHILD() .NODECONTEXTPUSH() (EX3 .OUT('if self.isParsed {' .LM+ .NL) / OUTPUT .OUT('if true {' .LM+ .NL) / NODE .OUT('if true {' .LM+ .NL) )
      $(EX3 .OUT('if !self.isParsed { try self.err() }' .NL) / OUTPUT / NODE )
      .OUT(.LM- '}' .NL) .NODECONTEXTPOP()
      ;

EX3 = ID        .OUT('try self.rule' * '()' .NL) .NODE(.NODEID) .NODEADDCHILD() /
      STRING    .OUT('self.test(' 34 * 34 ')' .NL) .NODE(.NODESTRING) .NODEADDCHILD() /
      '(' EX1 ')'                            /
      '.EMPTY'  .OUT('self.isParsed = true' .NL) .NODE(.NODEEMPTY) .NODEADDCHILD()    /
      '.LITCHR' .OUT('self.token = String(Array(self.inbuf.utf8)[self.inp])' .NL) .NODE(.NODEREADCHAR) .NODEADDCHILD()
                .OUT('self.inp += 1' .NL) /
      '$' .OUT('self.isParsed = true' .NL)
          .OUT('while self.isParsed {' .LM+ .NL)
          .NODE(.NODEZEROORMORE)
          .NODEADDCHILD()
          .NODECONTEXTPUSH()
           EX3
          .NODECONTEXTPOP()
          .OUT(.LM- '}' .NL)
          .OUT('self.isParsed = true' .NL)
          ;

[ output expressions ]
OUTPUT = '.OUT' '(' .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH() $OUT1 .NODECONTEXTPOP() ')'
         ;

OUT1 = '*'     .OUT('self.out(self.token)' .NL) .NODE(.NODETEXT 'self.out(self.token)' .NL) /
       STRING  .OUT('self.out(' 34 * 34 ')' .NL) .NODE(.NODETEXT 'self.out(' 34 * 34 ')' .NL) /
       NUMBER  .OUT('self.out(String(UnicodeScalar(' * ')))' .NL) .NODE(.NODETEXT 'self.out(String(UnicodeScalar(' * ')))' .NL) /
       '.NL'   .OUT('self.eol()' .NL) .NODE(.NODETEXT 'self.eol()' .NL) /
       '.LM+'  .OUT('self.stack[self.stack.count - 1].leftMargin += 4' .NL) .NODE(.NODETEXT 'self.stack[self.stack.count - 1].leftMargin += 4' .NL) /
       '.LM-'  .OUT('self.stack[self.stack.count - 1].leftMargin -= 4' .NL) .NODE(.NODETEXT 'self.stack[self.stack.count - 1].leftMargin -= 4' .NL)
       ;

[ .NODE( .NODE_COMMENT '//' * ' compiler' ) ]
[node expressions ]
NODE = '.NODECONTEXTPUSH' '(' ')' .OUT('self.pushLastChildAsNodeContext()' .NL) .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH() .NODE(.NODETEXT 'self.pushLastChildAsNodeContext()' .NL) .NODECONTEXTPOP() /
       '.NODECONTEXTPOP' '(' ')'  .OUT('self.popNodeContext()' .NL) .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH() .NODE(.NODETEXT 'self.popNodeContext()' .NL) .NODECONTEXTPOP() /
       '.NODESTASHPOP' '(' ')'  .OUT('self.popNodeStash()' .NL) .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH() .NODE(.NODETEXT 'self.popNodeStash()' .NL) .NODECONTEXTPOP() /
       '.NODESTASHPUSH' '(' ')'  .OUT('self.stash(node: latestNode!)' .NL) .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH() .NODE(.NODETEXT 'self.stash(node: latestNode!)' .NL) .NODECONTEXTPOP() /
       '.NODEADDCHILD' '(' ')'  .OUT('self.add(childNode: latestNode!)' .NL) .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH() .NODE(.NODETEXT 'self.add(childNode: latestNode!)' .NL) .NODECONTEXTPOP() /
       '.NODE' .NODE(.NODEOUTPUT) .NODEADDCHILD() .NODECONTEXTPUSH() '(' NODETYPE ')' .NODECONTEXTPOP()
       ;

NODETYPE = '.NODEOUTPUT' .OUT('latestNode = Node(type: .output)' .NL ) .NODE(.NODETEXT 'latestNode = Node(type: .output)' .NL) /
           '.NODERULE' .OUT('latestNode = Node(type: .rule(value: self.token))' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .rule(value: self.token))' .NL) /
           '.NODECOMMENT' .OUT('latestNode = Node(type: .comment(value: self.token))' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .comment(value: self.token))' .NL) /
           '.NODEID' .OUT('latestNode = Node(type: .id(value: self.token))' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .id(value: self.token))' .NL) /
           '.NODETOKENEXPRESSION' .OUT('latestNode = Node(type: .tokenExpression)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .tokenExpression)' .NL) /
           '.NODETOKENSTART' .OUT('latestNode = Node(type: .tokenStart)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .tokenStart)' .NL) /
           '.NODETOKENEND' .OUT('latestNode = Node(type: .tokenEnd)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .tokenEnd)' .NL) /
           '.NODETOKENANYBUT' .OUT('latestNode = Node(type: .tokenAnyBut)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .tokenAnyBut)' .NL) /
           '.NODETOKENANY' .OUT('latestNode = Node(type: .tokenAny)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .tokenAny)' .NL) /
           '.NODECHAREXPRESSION' .OUT('latestNode = Node(type: .charExpression)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .charExpression)' .NL) /
           '.NODECHAREQUAL' .OUT('latestNode = Node(type: .charEqual)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .charEqual)' .NL) /
           '.NODECHARLESSTHANEQUAL' .OUT('latestNode = Node(type: .charLessThanOrEqual)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .charLessThanOrEqual)' .NL) /
           '.NODECHARGREATERTHANEQUAL' .OUT('latestNode = Node(type: .charGreaterThanOrEqual)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .charGreaterThanOrEqual)' .NL) /
           '.NODESTRING' .OUT('latestNode = Node(type: .string(value: self.token))' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .string(value: self.token))' .NL) /
           '.NODENUMBER' .OUT('latestNode = Node(type: .number(value: self.token))' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .number(value: self.token))' .NL) /
           '.NODECHAR' .OUT('latestNode = Node(type: .character(value: self.token))' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .character(value: self.token))' .NL) /
           '.NODETEXT' $NODETEXTCONTENT /
           '.NODEREADCHAR' .OUT('latestNode = Node(type: .readCharacter)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .readCharacter)' .NL)  /
           '.NODEEMPTY' .OUT('latestNode = Node(type: .empty)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .empty)' .NL)  /
           '.NODEOR' .OUT('latestNode = Node(type: .or)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .or)' .NL)  /
           '.NODEAND' .OUT('latestNode = Node(type: .and)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .and)' .NL)  /
           '.NODEZEROORMORE' .OUT('latestNode = Node(type: .zeroOrMore)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .zeroOrMore)' .NL)
                         ;

NODETEXTCONTENT = '*'    .OUT('latestNode = Node(type: .text(value: self.token))' .NL 'add(childNode: latestNode!)' .NL ) .NODE(.NODETEXT 'latestNode = Node(type: .text(value: self.token))' .NL 'add(childNode: latestNode!)' .NL ) /
                  STRING .OUT('latestNode = Node(type: .text(value: ' 34 * 34 '))' .NL 'add(childNode: latestNode!)' .NL ) .NODE(.NODETEXT 'latestNode = Node(type: .text(value: ' 34 * 34 '))' .NL 'add(childNode: latestNode!)' .NL ) /
                  NUMBER .OUT('latestNode = Node(type: .text(value: String(UnicodeScalar(' * '))))' .NL 'add(childNode: latestNode!)' .NL ) .NODE(.NODETEXT 'latestNode = Node(type: .text(value: String(UnicodeScalar(' * '))))' .NL 'add(childNode: latestNode!)' .NL ) /
                  '.NL'  .OUT('latestNode = Node(type: .text(value: ' 34 92 'n' 34 '))' .NL 'add(childNode: latestNode!)' .NL ) .NODE(.NODETEXT 'latestNode = Node(type: .text(value: ' 34 92 'n' 34 '))' .NL 'add(childNode: latestNode!)' .NL ) /
                  '.LM+' .OUT('latestNode = Node(type: .leftMargin(margin: self.stack[self.stack.count - 1].leftMargin))' .NL 'add(childNode: latestNode!)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .leftMargin(margin: self.stack[self.stack.count - 1].leftMargin))' .NL 'add(childNode: latestNode!)' .NL) /
                  '.LM-' .OUT('latestNode = Node(type: .leftMargin(margin: self.stack[self.stack.count - 1].leftMargin))' .NL 'add(childNode: latestNode!)' .NL) .NODE(.NODETEXT 'latestNode = Node(type: .leftMargin(margin: self.stack[self.stack.count - 1].leftMargin))' .NL 'add(childNode: latestNode!)' .NL)
                  ;

[ token expressions ]
TX1 = .NODE(.NODETOKENEXPRESSION) .NODEADDCHILD() .NODECONTEXTPUSH() .NODE(.NODEOR) .NODEADDCHILD() .NODECONTEXTPUSH() TX2 $('/' .OUT('if !self.isParsed {' .LM+ .NL) TX2 .OUT(.LM- '}' .NL) ) .NODECONTEXTPOP() .NODECONTEXTPOP()
      ;

TX2 = .NODE(.NODEAND) .NODEADDCHILD() .NODECONTEXTPUSH() TX3 .OUT('if self.isParsed {' .LM+ .NL)
      $(TX3 .OUT('if !self.isParsed { return }' .NL))
      .OUT(.LM- '}' .NL)
      .NODECONTEXTPOP()
      ;

TX3 = ( '.TOKEN'  .OUT('self.isToken = true' .NL)
                  .OUT('self.token = ' 34 34 .NL) .NODE(.NODETOKENSTART) .NODEADDCHILD() /
        '.DELTOK' .OUT('self.isToken = false' .NL) .NODE(.NODETOKENEND) .NODEADDCHILD() /
        '$' .OUT('self.isParsed = true' .NL)
            .OUT('while self.isParsed {' .LM+ .NL)
            .NODE(.NODEZEROORMORE)
            .NODEADDCHILD()
            .NODECONTEXTPUSH()
             TX3
            .NODECONTEXTPOP()
            .OUT(.LM- '}' .NL)
        )
        .OUT('self.isParsed = true' .NL) /
      '.ANYBUT(' .NODE(.NODETOKENANYBUT) .NODEADDCHILD() .NODECONTEXTPUSH() CX1 .NODECONTEXTPOP() ')'
        .OUT('self.isParsed = !self.isParsed' .NL)
        .OUT('if self.isParsed {' .LM+ .NL)
        .OUT('if self.isToken { self.token += String(UnicodeScalar(Array(self.inbuf.utf8)[self.inp])) }' .NL)
        .OUT('self.inp += 1 }' .LM- .NL) /
      '.ANY(' .NODE(.NODETOKENANY) .NODEADDCHILD() .NODECONTEXTPUSH() CX1 .NODECONTEXTPOP() ')'
        .OUT('if self.isParsed {' .LM+ .NL)
        .OUT('if self.isToken { self.token += String(UnicodeScalar(Array(self.inbuf.utf8)[self.inp])) }' .NL)
        .OUT('self.inp += 1 }' .LM- .NL) /
      ID
        .OUT('try self.rule' * '()' .NL)
        .NODE(.NODEID) .NODEADDCHILD() /
      '(' TX1 ')'  ;

[ character expressions ]
CX1 = .OUT('self.isParsed =' .LM+ .NL) .NODE(.NODECHAREXPRESSION) .NODEADDCHILD() .NODECONTEXTPUSH()
      .NODE(.NODEOR) .NODEADDCHILD() .NODECONTEXTPUSH() CX2 $('!' .OUT(' ||' .NL) CX2) .NODECONTEXTPOP()
      .OUT(.LM- .NL) .NODECONTEXTPOP()
      ;
CX2 = CX3 .NODESTASHPUSH()
          (':' .NODE(.NODEAND) .NODEADDCHILD() .NODECONTEXTPUSH() .OUT('( Array(self.inbuf.utf8)[self.inp] >= ' * ' &&' .NL) .NODE(.NODECHARGREATERTHANEQUAL) .NODEADDCHILD() .NODECONTEXTPUSH() .NODESTASHPOP() .NODECONTEXTPOP()
              CX3 .NODESTASHPUSH() .OUT(' Array(self.inbuf.utf8)[self.inp] <= ' * ' )') .NODE(.NODECHARLESSTHANEQUAL) .NODEADDCHILD() .NODECONTEXTPUSH() .NODESTASHPOP() .NODECONTEXTPOP() .NODECONTEXTPOP() /
          .EMPTY .OUT('Array(self.inbuf.utf8)[self.inp] == ' * ) .NODE(.NODECHAREQUAL) .NODEADDCHILD() .NODECONTEXTPUSH() .NODESTASHPOP() .NODECONTEXTPOP() )
      ;
CX3 = NUMBER .NODE(.NODENUMBER) / SQUOTE .LITCHR .NODE(.NODECHAR);

[ token definitions ]
.TOKENS

PREFIX : $.ANY(32!9!13!10) ;
ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;
NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;
STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;
ALPHA  : .ANY('A:'Z!'a:'z) ;
DIGIT  : .ANY('0:'9) ;
SQUOTE : PREFIX .ANY('') ;
CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;

.END

