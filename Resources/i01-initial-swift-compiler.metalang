.SYNTAX PROGRAM

[ body of compiler definition ]
PROGRAM = '.SYNTAX' ID
          .OUT(.LB '// ' * ' compiler' .NL)
          .OUT('public class Compiler {' .LM+ .NL .NL)
          PREAMBLE
          $(PR / COMMENT)
          '.TOKENS'
          $(TR / COMMENT)
          '.END'
          POSTAMBLE
          .OUT(.LM- '}' .NL) ;

[ object definition preamble ]
PREAMBLE = .OUT('public func compile(_ input: String) -> Bool {' .LM+ .NL)
           .OUT('// initialize compiler variables' .NL)
           .OUT('self.inbuf = input' .NL)
           .OUT('self.initialize()' .NL)
           .OUT('// call the first rule' .NL)
           .OUT('self.contextPush(' 34 * 34 ')' .NL)
           .OUT('self.rule' * '()' .NL)
           .OUT('self.contextPop()' .NL)
           .OUT('// special case handling of first rule failure' .NL)
           .OUT('if !self.isError && !self.isParsed {' .LM+ .NL)
           .OUT('self.isError = true' .NL)
           .OUT('self.erule = ' 34 * 34 '' .NL)
           .OUT('self.einput = self.inp }' .LM- .NL)
           .OUT('return !self.isError' .NL)
           .OUT(.LM- '}' .NL .NL) ;


[ runtime and object definition postamble ]
POSTAMBLE =

           .OUT('struct StackFrame {' .LM+ .NL)
           .OUT('var erule: String' .NL)
           .OUT('var leftMargin: Int' .NL)
           .OUT(.LM- '}' .NL)

           .OUT('// runtime variables' .NL)
           .OUT('var isParsed = false' .NL)
           .OUT('var isToken = false' .NL)
           .OUT('var isError = false' .NL)
           .OUT('var inp = 0' .NL)
           .OUT('var inbuf = ' 34 34 .NL)
           .OUT('public var outputBuffer = ' 34 34 .NL)
           .OUT('public var erule = ' 34 34  .NL)
           .OUT('public var einput = 0' .NL)
           .OUT('public var token = ' 34 34 .NL)
           .OUT('var stack: [StackFrame] = []' .NL .NL)

           .OUT('public init() {'.LM+ .NL)
           .OUT('self.initialize()' .NL)
           .OUT(.LM- '}' .NL .NL)

           .OUT('func initialize () {'.LM+ .NL)
           .OUT('// initialize for another compile' .NL)
           .OUT('self.isParsed = false' .NL)
           .OUT('self.isToken = false' .NL)
           .OUT('self.isError = false' .NL)
           .OUT('self.inp = 0' .NL)
           .OUT('self.outputBuffer = ' 34 34 .NL)
           .OUT('self.erule = ' 34 34 .NL)
           .OUT('self.einput = 0' .NL)
           .OUT('self.token = ' 34 34 .NL)
           .OUT('self.stack = []' .NL)
           .OUT(.LM- '}' .NL .NL)

           .OUT('func contextPush (_ rulename: String) {' .LM+ .NL)
           .OUT('// push and initialize a new stackframe' .NL)
           .OUT('// new context inherits current context left margin' .NL)
           .OUT('var leftMargin = 0' .NL 'if self.stack.count >= 1 { leftMargin = self.stack[self.stack.count - 1].leftMargin }' .NL)
           .OUT('// stackframe definition' .NL)
           .OUT('self.stack.append(StackFrame(erule: rulename, leftMargin: leftMargin))' .NL)
           .OUT(.LM- '}' .NL .NL)

           .OUT('func contextPop () {' .LM+ .NL)
           .OUT('// pop and possibly deallocate old stackframe' .NL)
           .OUT('_ = self.stack.popLast() // pop stackframe' .NL)
           .OUT(.LM- '}' .NL .NL)

           .OUT('func out (_ output: String) {' .LM+ .NL)
           .OUT('// output string' .NL)
           .OUT('var indent = 0' .NL)
           .OUT('// if newline last output, add left margin before string' .NL)
           .OUT('if self.outputBuffer.count > 0 && String(UnicodeScalar(Array(self.outputBuffer.utf8)[self.outputBuffer.count - 1])) == ' 34 92 'n' 34 ' {' .NL)
           .OUT('  indent = self.stack[self.stack.count - 1].leftMargin' .NL)
           .OUT('  while indent > 0 { self.outputBuffer += ' 34 ' ' 34 '; indent -= 1 } }' .NL)
           .OUT('self.outputBuffer += output' .NL)
           .OUT(.LM- '}' .NL .NL)

           .OUT('func eol () {' .LM+ .NL)
           .OUT('// output end of line' .NL)
           .OUT('self.outputBuffer += ' 34 92 'n' 34 .NL)
           .OUT(.LM- '}' .NL .NL)

           .OUT('func test (_ stringToCompare: String) {' .LM+ .NL)
           .OUT('// test for a string in the input' .NL)
           .OUT('var inputOffset = 0' .NL)
           .OUT('// delete whitespace' .NL)
           .OUT('while Array(self.inbuf.utf8)[self.inp] == 32 ||' .NL)
           .OUT('       Array(self.inbuf.utf8)[self.inp] == 9 ||' .NL)
           .OUT('       Array(self.inbuf.utf8)[self.inp] == 13 ||' .NL)
           .OUT('       Array(self.inbuf.utf8)[self.inp] == 10 { self.inp += 1}' .NL)
           .OUT('// test string case insensitive' .NL)
           .OUT('self.isParsed = true' .NL)
.OUT('while self.isParsed && (inputOffset < stringToCompare.count) && ((self.inp + inputOffset) < self.inbuf.count) {' .NL)
           .OUT('self.isParsed = String(UnicodeScalar(Array(stringToCompare.utf8)[inputOffset])).uppercased() ==' .NL)
           .OUT('                String(UnicodeScalar(Array(self.inbuf.utf8)[self.inp + inputOffset])).uppercased()' .NL)
           .OUT('  inputOffset += 1 }' .NL)
           .OUT('self.isParsed = self.isParsed && (inputOffset == stringToCompare.count)' .NL)
           .OUT('// advance input if found' .NL)
           .OUT('if self.isParsed { self.inp = self.inp + stringToCompare.count }' .NL)
           .OUT(.LM- '}' .NL .NL)

           .OUT('func err() {' .LM+ .NL)
           .OUT('// compilation error, provide error indication and context' .NL)
           .OUT('self.isError = true' .NL)
           .OUT('self.erule = self.stack[self.stack.count - 1].erule' .NL)
           .OUT('self.einput = self.inp' .NL)
           .OUT(.LM- '}' .NL .NL) ;

[ parsing rule definition ]
PR = ID .OUT('func rule'* '() {' .LM+ .NL)
     '=' EX1 ';'
     .OUT(.LM- '}' .NL .NL) ;

[ token rule definition ]
TR = ID .OUT('func rule'* '() {' .LM+ .NL)
     ':' TX1 ';'
     .OUT(.LM- '}' .NL .NL) ;

[ comment definition ]
COMMENT = '[' CMLINE ']' .OUT('//' * .NL) ;

[ parsing expressions ]
EX1 = EX2 $('/' .OUT('if !self.isParsed {' .LM+ .NL) EX2 .OUT(.LM- '}' .NL) ) ;

EX2 = (EX3 .OUT('if self.isParsed {' .LM+ .NL) / OUTPUT .OUT('if true {' .LM+ .NL) )
      $(EX3 .OUT('if !self.isParsed { self.err() }' .NL) / OUTPUT)
      .OUT(.LM- '}' .NL) ;


EX3 = ID        .OUT('self.contextPush(' 34 * 34 ')' .NL)
                .OUT('self.rule' * '()' .NL)
                .OUT('self.contextPop()' .NL)
                .OUT('if self.isError { return }' .NL)  /
      STRING    .OUT('self.test(' 34 * 34 ')' .NL) /
      '(' EX1 ')'                            /
      '.EMPTY'  .OUT('self.isParsed = true' .NL)    /
      '.LITCHR' .OUT('self.token = String(Array(self.inbuf.utf8)[self.inp])' .NL)
                .OUT('self.inp += 1' .NL)  /
      '$' .OUT('self.isParsed = true' .NL)
          .OUT('while self.isParsed {' .LM+ .NL)
           EX3
          .OUT(.LM- '}' .NL)
          .OUT('self.isParsed = true' .NL) ;

[ output expressions ]
OUTPUT = '.OUT' '('$OUT1 ')' ;

OUT1 = '*'     .OUT('self.out(self.token)' .NL)          /
       STRING  .OUT('self.out(' 34 * 34 ')' .NL) /
       NUMBER  .OUT('self.out(String(UnicodeScalar(' * ')))' .NL)        /
       '.NL'   .OUT('self.eol()' .NL)          /
       '.LB'             /
       '.TB'   .OUT('self.out(' 34 92 't' 34 ')' .NL)          /
       '.LM+'  .OUT('self.stack[self.stack.count - 1].leftMargin += 4' .NL) /
       '.LM-'  .OUT('self.stack[self.stack.count - 1].leftMargin -= 4' .NL) ;

[ token expressions ]
TX1 = TX2 $('/' .OUT('if !self.isParsed {' .LM+ .NL) TX2 .OUT(.LM- '}' .NL) ) ;

TX2 = TX3 .OUT('if self.isParsed {' .LM+ .NL)
      $(TX3 .OUT('if !self.isParsed { return }' .NL) )
      .OUT(.LM- '}' .NL) ;

TX3 = ( '.TOKEN'  .OUT('self.isToken = true' .NL)
                  .OUT('self.token = ' 34 34 .NL) /
        '.DELTOK' .OUT('self.isToken = false' .NL) /
        '$' .OUT('self.isParsed = true' .NL)
            .OUT('while self.isParsed {' .LM+ .NL)
             TX3
            .OUT(.LM- '}' .NL) )
        .OUT('self.isParsed = true' .NL) /
      '.ANYBUT(' CX1 ')' .OUT('self.isParsed = !self.isParsed' .NL)
        .OUT('if self.isParsed {' .LM+ .NL)
        .OUT('if self.isToken { self.token += String(UnicodeScalar(Array(self.inbuf.utf8)[self.inp])) }' .NL)
        .OUT('self.inp += 1 }' .LM- .NL) /
      '.ANY(' CX1 ')'
        .OUT('if self.isParsed {' .LM+ .NL)
        .OUT('if self.isToken { self.token += String(UnicodeScalar(Array(self.inbuf.utf8)[self.inp])) }' .NL)
        .OUT('self.inp += 1 }' .LM- .NL) /
      ID
        .OUT('self.contextPush(' 34 * 34 ')' .NL)
        .OUT('self.rule' * '()' .NL)
        .OUT('self.contextPop()' .NL)
        .OUT('if self.isError { return }' .NL)  /
      '(' TX1 ')'  ;

[ character expressions ]
CX1 = .OUT('self.isParsed =' .LM+ .NL)
      CX2 $('!' .OUT(' ||' .NL) CX2)
      .OUT(.LM- .NL) ;
CX2 = CX3 (':' .OUT('(Array(self.inbuf.utf8)[self.inp] >= ' * ' ) &&' .NL)
               CX3
               .OUT(' (Array(self.inbuf.utf8)[self.inp] <= ' * '  )' ) /
           .EMPTY .OUT('Array(self.inbuf.utf8)[self.inp] == ' * ' ' )  ) ;
CX3 = NUMBER / SQUOTE .LITCHR ;

[ token definitions ]
.TOKENS

PREFIX : $.ANY(32!9!13!10) ;
ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;
NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;
STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;
ALPHA  : .ANY('A:'Z!'a:'z) ;
DIGIT  : .ANY('0:'9) ;
SQUOTE : PREFIX .ANY('') ;
CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;

.END

